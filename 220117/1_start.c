#include <stdio.h>
#define PI 3.14		//얘는 컴파일 단계전에 모두 3.14로 치환된다.
// #으로 시작하는 애들 : 전처리기(컴파일이전에 수행됩니다,preprocessor)
//		Compile			Linking
// 1.c	-> 1.obj	1.obj+2.obj+3.obj	=>	a.exe(windows의 경우 PE포맷)
// 2.c	-> 2.obj						=>	a.out(linux의 경우 ELF포멧)		서로 다른 OS에서 만들어진 포맷은 다른 OS에서 실행X
// 3.c	-> 3.obj
// =====================================
// VM기반 언어 : Java, C#, Kotlin, Go...
// a.java->a.class<-java.exe
//		(가상머신이 해석할 수 있는 기계어)-바이트코드/IL(중간언어)
// a.exe는 windows에서밖에 안돈다. 즉 platform에 종속적이지만
// java는 그 플랫폼에 깔려있는 java.exe.가 돌려준다. 그래서 플랫폼에 관계없이 돌릴 수 있게 된다.
// 
// 컴파일러를 바꾼다는 것은 최적화의 방법이나 바이너리의 특성이 다르다
// 
//1. 컴파일러
//	-MS C/C++ compiler : cl.exe
//	-GNU Compiler : gcc								cc(c)/g++(c++)
//	-LLVM : clang : Lightweight Virtual Machine		cc(clang)/g++(clang++)
//   1.c->중간언어를 만듬->1.obj
//         중간언어를 만듬으로써 platform을 초월하기 시작

//2. 확장자
//	-C	: .c
//	-C++ : .cpp,cc(google),cxx,C ... 이는 각 회사마다 다르다(convention)

//3. main함수
//	->프로그램의 시작함수
//	->Entry point(반드시 한개만 있어야 함)
//	->표준(중요) 어느 플랫폼에서 쓰느냐에 따라 결과가 달라질 수 있다.
// 함수의 반환타입 함수이름(함수 파라미터 정보)
//	-main함수
//	:반환 타입은 int이다
//		0:프로세스의 성공
//		0아님:프로세서의 실패 코드
// int main(int argc, char* argv[])
//	:프로그램의 명령인수를 받을 경우 사용하는 main문

//4. header파일
//	-함수의 시그니처의 정보를 컴파일러에게 알려준다.
//	-실제 구현은 사실 다른 라이브러리에 있고, 이 부분은 링크과정에서 연결이 수행
//	-일반적으로 c라이브러리에 대한 연결은 암묵적으로 수행된다(프로그래머가 뭘 더 해줄 필요는 없다.)
//	-만약 서드파티 라이브러리같은 경우에는 링킹을 별도로 다 해주어야 한다.

//5. 라이브러리/엔진/프레임워크
//	-라이브러리 : 함수/클래스의 집합
//	-엔진		: 게임엔진(게임을 개발하기 위해 필요한 라이브러리의 집합)
//	-프레임워크	: 라이브러리의 집합. 미리 정의된 흐름이 존재. 흐름에 맞게 혹은 룰에 맞게 코드를 작성해야한다.

//6. 주석
//	-라인주석 //
//	-블럭주석 /* */
//	주석이 많으면 유지보수 시 비용이 증가하게된다.
//	제일 좋은건 주석 없이도 코드 잘 짜는것
//	블럭 주석의 단점은 '중첩'이 안된다는것
//	/*
//	/*
//	*/
//	*/		여기서 에러생김
// 
//	#if 0 ~ endif를 사용


//warning은 사실 빌드에 방해가 되지는 않으나 error로 취급하는 것이 맞다.
int main(void)
{
	printf("Hello world\n");
	return 0;
}